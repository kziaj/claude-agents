#!/bin/bash

# Claude Command: Validate Verified Model Standards
# Usage: validate-verified-standards [--fix]
# Description: Validates that models in models_verified/ follow all verified/ standards

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

# Function to print colored output
print_header() {
    echo -e "${PURPLE}═══════════════════════════════════════════════${NC}"
    echo -e "${PURPLE}$1${NC}"
    echo -e "${PURPLE}═══════════════════════════════════════════════${NC}"
}

print_check() {
    echo -e "${BLUE}[CHECK]${NC} $1"
}

print_pass() {
    echo -e "${GREEN}✅ PASS${NC} $1"
}

print_fail() {
    echo -e "${RED}❌ FAIL${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠️  WARN${NC} $1"
}

print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

# Detect project directory
if [ -f "dbt_project.yml" ]; then
    DBT_PROJECT_DIR="$(pwd)"
elif [ -d "$HOME/ds-redshift" ] && [ -f "$HOME/ds-redshift/dbt_project.yml" ]; then
    DBT_PROJECT_DIR="$HOME/ds-redshift"
elif [ -d "$HOME/carta/ds-dbt" ] && [ -f "$HOME/carta/ds-dbt/dbt_project.yml" ]; then
    DBT_PROJECT_DIR="$HOME/carta/ds-dbt"
else
    print_fail "Could not find dbt project. Run from project directory or ensure ~/ds-redshift exists"
    exit 1
fi

cd "$DBT_PROJECT_DIR"

VERIFIED_DIR="models/models_verified"
FAILED_CHECKS=0
TOTAL_CHECKS=0

# Check if verified directory exists
if [ ! -d "$VERIFIED_DIR" ]; then
    print_warning "No models_verified/ directory found. Nothing to validate."
    exit 0
fi

print_header "Verified Model Standards Validation"
echo ""

#############################################
# CHECK 1: No alias configs in verified/
#############################################
TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
print_check "Check 1: No 'alias=' configs in models_verified/"

ALIAS_VIOLATIONS=$(grep -r "alias=" "$VERIFIED_DIR" --include="*.sql" 2>/dev/null || true)

if [ -z "$ALIAS_VIOLATIONS" ]; then
    print_pass "No alias configs found"
else
    print_fail "Found alias configs in verified/ models"
    FAILED_CHECKS=$((FAILED_CHECKS + 1))
    echo ""
    echo "Violations:"
    echo "$ALIAS_VIOLATIONS" | sed 's/^/  /'
    echo ""
    echo "Fix: Remove alias= from config blocks in these files."
    echo "Verified models don't need aliases - filename = table name."
fi
echo ""

#############################################
# CHECK 2: No SELECT * in verified/
#############################################
TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
print_check "Check 2: No 'SELECT *' in models_verified/"

SELECT_STAR_VIOLATIONS=$(grep -r "SELECT \*" "$VERIFIED_DIR" --include="*.sql" 2>/dev/null || true)

if [ -z "$SELECT_STAR_VIOLATIONS" ]; then
    print_pass "No SELECT * found"
else
    print_fail "Found SELECT * in verified/ models"
    FAILED_CHECKS=$((FAILED_CHECKS + 1))
    echo ""
    echo "Violations:"
    echo "$SELECT_STAR_VIOLATIONS" | sed 's/^/  /'
    echo ""
    echo "Fix: Replace SELECT * with explicit column lists."
    echo "Use dbt-refactor-agent to expand SELECT * automatically."
fi
echo ""

#############################################
# CHECK 3: All SQL files have matching YAML
#############################################
TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
print_check "Check 3: All .sql files have matching .yml files"

MISSING_YAML_COUNT=0
MISSING_YAML_FILES=""

while IFS= read -r sql_file; do
    # Get base name without extension
    base_name=$(basename "$sql_file" .sql)
    dir_name=$(dirname "$sql_file")
    
    # Check for matching YAML file
    yml_file="${dir_name}/${base_name}.yml"
    
    if [ ! -f "$yml_file" ]; then
        MISSING_YAML_COUNT=$((MISSING_YAML_COUNT + 1))
        MISSING_YAML_FILES="${MISSING_YAML_FILES}\n  ${sql_file} → missing ${yml_file}"
    fi
done < <(find "$VERIFIED_DIR" -type f -name "*.sql")

if [ $MISSING_YAML_COUNT -eq 0 ]; then
    print_pass "All SQL files have matching YAML files"
else
    print_fail "Found $MISSING_YAML_COUNT SQL files without matching YAML"
    FAILED_CHECKS=$((FAILED_CHECKS + 1))
    echo ""
    echo "Missing YAML files:"
    echo -e "$MISSING_YAML_FILES"
    echo ""
    echo "Fix: Create matching .yml files for each .sql file."
fi
echo ""

#############################################
# CHECK 4: All models have descriptions
#############################################
TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
print_check "Check 4: All models have description: field in YAML"

# This check requires poetry/pre-commit to be available
if command -v poetry &> /dev/null; then
    print_info "Running pre-commit check-model-has-description..."
    
    if poetry run pre-commit run check-model-has-description --files "$VERIFIED_DIR"/**/*.sql &>/dev/null; then
        print_pass "All models have descriptions"
    else
        print_fail "Some models missing descriptions"
        FAILED_CHECKS=$((FAILED_CHECKS + 1))
        echo ""
        echo "Run: poetry run pre-commit run check-model-has-description --all-files"
        echo "to see which models need descriptions."
    fi
else
    print_warning "Poetry not available, skipping description check"
    TOTAL_CHECKS=$((TOTAL_CHECKS - 1))
fi
echo ""

#############################################
# CHECK 5: YAML model names match filenames
#############################################
TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
print_check "Check 5: YAML 'name:' fields match SQL filenames"

YAML_NAME_MISMATCHES=0
YAML_NAME_ISSUES=""

while IFS= read -r yml_file; do
    base_name=$(basename "$yml_file" .yml)
    
    # Extract the 'name:' field from YAML (first model name)
    yaml_model_name=$(grep -A 1 "^models:" "$yml_file" | grep "name:" | head -1 | sed 's/.*name: *//' | tr -d '"' | tr -d "'" || true)
    
    if [ -n "$yaml_model_name" ] && [ "$yaml_model_name" != "$base_name" ]; then
        YAML_NAME_MISMATCHES=$((YAML_NAME_MISMATCHES + 1))
        YAML_NAME_ISSUES="${YAML_NAME_ISSUES}\n  ${yml_file}: name='${yaml_model_name}' but filename is '${base_name}.yml'"
    fi
done < <(find "$VERIFIED_DIR" -type f -name "*.yml")

if [ $YAML_NAME_MISMATCHES -eq 0 ]; then
    print_pass "All YAML names match filenames"
else
    print_fail "Found $YAML_NAME_MISMATCHES YAML files with mismatched names"
    FAILED_CHECKS=$((FAILED_CHECKS + 1))
    echo ""
    echo "Mismatches:"
    echo -e "$YAML_NAME_ISSUES"
    echo ""
    echo "Fix: Update the 'name:' field in YAML to match the SQL filename."
fi
echo ""

#############################################
# CHECK 6: No orphaned YAML files
#############################################
TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
print_check "Check 6: No orphaned .yml files (YAML without SQL)"

ORPHANED_YAML_COUNT=0
ORPHANED_YAML_FILES=""

while IFS= read -r yml_file; do
    base_name=$(basename "$yml_file" .yml)
    dir_name=$(dirname "$yml_file")
    
    # Check for matching SQL file
    sql_file="${dir_name}/${base_name}.sql"
    
    if [ ! -f "$sql_file" ]; then
        ORPHANED_YAML_COUNT=$((ORPHANED_YAML_COUNT + 1))
        ORPHANED_YAML_FILES="${ORPHANED_YAML_FILES}\n  ${yml_file} → missing ${sql_file}"
    fi
done < <(find "$VERIFIED_DIR" -type f -name "*.yml")

if [ $ORPHANED_YAML_COUNT -eq 0 ]; then
    print_pass "No orphaned YAML files"
else
    print_warning "Found $ORPHANED_YAML_COUNT orphaned YAML files"
    echo ""
    echo "Orphaned YAML files:"
    echo -e "$ORPHANED_YAML_FILES"
    echo ""
    echo "Fix: Either create matching .sql files or delete orphaned .yml files."
fi
echo ""

#############################################
# CHECK 7: dbt parse succeeds
#############################################
TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
print_check "Check 7: dbt parse compiles without errors"

if command -v poetry &> /dev/null; then
    print_info "Running dbt parse..."
    
    # Source .env if it exists
    if [ -f ".env" ]; then
        source .env
    fi
    
    if poetry run dbt parse &>/dev/null; then
        print_pass "dbt parse succeeded"
    else
        print_fail "dbt parse failed - models have compilation errors"
        FAILED_CHECKS=$((FAILED_CHECKS + 1))
        echo ""
        echo "Run: poetry run dbt parse"
        echo "to see detailed error messages."
    fi
else
    print_warning "Poetry not available, skipping dbt parse check"
    TOTAL_CHECKS=$((TOTAL_CHECKS - 1))
fi
echo ""

#############################################
# SUMMARY
#############################################
print_header "Validation Summary"
echo ""

PASSED_CHECKS=$((TOTAL_CHECKS - FAILED_CHECKS))

echo "Total Checks: $TOTAL_CHECKS"
echo "Passed: $PASSED_CHECKS"
echo "Failed: $FAILED_CHECKS"
echo ""

if [ $FAILED_CHECKS -eq 0 ]; then
    print_pass "All verified/ standards checks passed!"
    echo ""
    echo "✅ Your verified/ models are compliant and ready to commit."
    exit 0
else
    print_fail "$FAILED_CHECKS check(s) failed"
    echo ""
    echo "❌ Fix the violations above before committing to verified/."
    echo ""
    echo "Common fixes:"
    echo "  • Remove alias= configs from verified models"
    echo "  • Replace SELECT * with explicit column lists (use dbt-refactor-agent)"
    echo "  • Create matching .yml files for all .sql files"
    echo "  • Add description: fields to all models"
    echo "  • Update YAML name: fields to match filenames"
    exit 1
fi
